'From Moshi of 3 March 2007 [latest update: #1002] on 26 July 2009 at 4:47:26 pm'!Compiler subclass: #ESOOPCompiler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!ObjectDeParser subclass: #ESOOPDeParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!OrderedCollection subclass: #ESOOPList	instanceVariableNames: 'prime log0rel'	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!Object subclass: #ESOOPLog0Object	instanceVariableNames: 'string log0type log0listType log0listSize isaListInstVar'	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!ESOOPLog0Object subclass: #ESOOPLog0Atom	instanceVariableNames: ''	classVariableNames: 'AtomCtr AtomToObjMap'	poolDictionaries: ''	category: 'ESOOP'!ESOOPLog0Object subclass: #ESOOPLog0AtomExpr	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!ESOOPLog0Object subclass: #ESOOPLog0Formula	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!ESOOPLog0Object subclass: #ESOOPLog0Integer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!IdentityDictionary subclass: #ESOOPLog0Relation	instanceVariableNames: 'id instVar domain range fixedSize isaPrime isaList isaListInstVar subRels'	classVariableNames: 'RelCtr'	poolDictionaries: ''	category: 'ESOOP'!ESOOPLog0Object subclass: #ESOOPLog0Set	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!ESOOPLog0Object subclass: #ESOOPLog0Variable	instanceVariableNames: ''	classVariableNames: 'VarCtr'	poolDictionaries: ''	category: 'ESOOP'!Object subclass: #ESOOPLogSolver	instanceVariableNames: ''	classVariableNames: 'FirstTime Flatten Host Port ProblemRels QuitServerAfter Solver SolverSocket SymmetryBreaking'	poolDictionaries: ''	category: 'ESOOP'!OMeta2 subclass: #ESOOPLogSolverOutputParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!OMeta2 subclass: #ESOOPParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ESOOP'!Object subclass: #ESOOPUserTypes	instanceVariableNames: 'log0'	classVariableNames: 'UserTypes'	poolDictionaries: ''	category: 'ESOOP'!ESOOPUserTypes subclass: #ESOOPInteger	instanceVariableNames: 'value prime'	classVariableNames: 'Bounds MaxInt MinInt'	poolDictionaries: ''	category: 'ESOOP'!ESOOPUserTypes class	instanceVariableNames: 'instVarTypes log0instVarRels instAtomNumStart instCtr esoopInstances'!!ESOOPCompiler methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:29'!compile: origCode in: cls classified: aCategory notifying: notify ifFail: failBlock	^ self compile: origCode in: cls notifying: notify ifFail: failBlock! !!ESOOPCompiler methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 14:10'!compile: origCode in: cls notifying: notify ifFail: failBlock	| origCodeStream  codes trees translatedCode c last |      ESOOPLog0Object reset.	origCodeStream := origCode asString readStream.	self from: origCodeStream class: cls context: nil notifying: notify.      "self halt."	[		trees := ESOOPParser matchAll: origCodeStream with: #esoopProgram.	] on: OM2Fail do: [:ex |		"self notify: '<-- parse error around here -->' at: origCodeStream position.		^ failBlock value."             " assume squeak method... "            ^super compile: origCode in: cls notifying: notify ifFail: failBlock	].     codes := trees collect: [:tree |			[ESOOPDeParser match: tree with: #start]				on: OM2Fail do:			[				self notify: 'printing failed' at: origCodeStream size.				^ failBlock value.			] ].    1 to: codes size  do: [:ind |			translatedCode := codes at: ind.			c := cls.			(trees at: ind) first = #esoopMethod                     ifTrue: [				c := Smalltalk at: (trees at: ind) second second.                        last := ind < codes size                            ifTrue: [ c reallyBasicCompile: translatedCode classified: 'ESOOP'			            	        withStamp: nil notifying: notify logSource: false ]                         ifFalse: [ Compiler new				                  compile: translatedCode readStream in: cls				                  notifying: notify ifFail: failBlock ]  ]                     ifFalse: [ last := Compiler evaluate: translatedCode ] ].       ^last! !!ESOOPCompiler class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:26'!evaluate: program  | trees ret |    " inits "    ESOOPLog0Pointer resetPtrCtr.    ESOOPLog0Variable resetPtrCtr.    trees := ESOOPParser matchAll: program with: #esoopProgram.    trees do: [:tree | | translated |         translated := ESOOPDeParser match: tree with: #start.         "self halt."	   ret := super evaluate: translated ].    ^ret! !!ESOOPCompiler class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:26'!for: classNs mtdNames: mtdNs compile: mtdBody classified: c    1 to: classNs size do:       [:i | (Smalltalk at: (classNs at: i))                compile: (mtdNs at: i) , mtdBody classified: c ].    ^true! !!ESOOPCompiler class methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 22:54'!testAllAppsView    "        * bring up solver server first *       ESOOPCompiler testAllAppsView.     ""    | v1 grid |     ESOOPInteger setBounds: #(0 50).    grid := 60.    v1 := ESOOPAllAppsViewer new                  appNum: (ESOOPInteger new: 6); scale: (ESOOPInteger new: 1);                 xMax: ((ESOOPInteger new: 1200)/grid);                 yMax: ((ESOOPInteger new: 780)/grid);                 xs: (ESOOPList withAll: #(2 3 5 6 14 1));                 ys: (ESOOPList withAll: #(4 6 5 2 4 2));               ws: (ESOOPList withAll: #(8 2 8 8 4 2));                hs: (ESOOPList withAll: #(2 6 4 8 4 2)); yourself.     v1 draw.     v1 solve: #snapshot.     v1 draw.""function AllAppsViewer noAppsOverlap ∀ A1, A2 ∊ self boxes |                     A1 = A2 ∨                     A1 left′ > A2 left′ + A2 width′ ∨                     A2 left′ > A1 left′ + A1 width′ ∨                     A1 top′ > A2 top′ + A2 height′ ∨                     A2 top′ > A1 top′ + A1 height′. function AllAppsViewer noAppsOutOfScreen ∀ A ∊ self boxes |                      A left′+ A width′ < self xMax ∧                       A top′+ A height′ < self yMax.function AllAppsViewer properlyScaled                      ∀ A ∊ self boxes |                           A width′ * self scale = A width ∧                           A height′ * self scale = A height.goal AllAppsViewer snapshot               self noAppsOverlap ∧ self noAppsOutOfScreen ∧ self properlyScaled.""draw      | w g |      g := 60.	w := LesserphicMorph new openInWorld.      w extent: (g * xMax)@(g * yMax).      boxes do: [:box | | a |	  a := LBox extent:  (g * box width)@(g * box height) color: Color white.        a shape borderWidth: 2.	  w window add: a.	  a container translation: (g * box left)@(g * box top) ].	 ^true"! !!ESOOPCompiler class methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 16:36'!testPentominos    "        STEP 5: Run test (*uncomment this step after step 4*)       * bring up solver server first *       ESOOPCompiler testPentominos.    ""    | dirs squares fromDirs froms pentoShape |ESOOPInteger setBounds: #(-3 5).dirs := ESOOPList withAll: (#((0 1) (0 -1) (-1 0) (1 0)) collect:                [:p | ESOOPPoint new x: (ESOOPInteger new: p first);                                                     y: (ESOOPInteger new: p second); yourself ]).squares := ESOOPList withAll: ((1 to: 5) collect:                [:p | ESOOPPoint new x: (ESOOPInteger new: 0);                                                     y: (ESOOPInteger new: 0); yourself ]).froms := ESOOPList new.fromDirs := ESOOPList new. pentoShape := ESOOPPentoShapes new                               dirs: dirs; squares: squares; fromDirs: fromDirs;                               froms: froms; yourself.pentoShape solve: #findShape.^pentoShape squares.                   "                            "      STEP 1: Define Classes     ""    ESOOPUserTypes class: #Point subclass: #Point           instanceVariables: {{#x. #Integer. true}.                                             {#y. #Integer. true}}.     ESOOPUserTypes subclass: #PentoShapes       instanceVariables: {{#dirs. #List. false. #Point. 4}.                                          {#squares. #List. true. #Point. 5}.                                             {#froms. #List. true. #Integer. 5}.                                          {#fromDirs. #List. true. #Integer. 5}}."      "      STEP 2: Define predicate methods for ESOOPPoint  ""predicate Point equals: p      self x prime = p x prime and     self y prime = p y prime.predicate Point plus: p equals: q    self x prime + p x prime = q x prime and     self y prime + p y prime = q y prime.""      STEP 3: Define predicate methods for ESOOPPentoShapes  ""predicate PentoShapes atOrigin    (self squares at: 1) x prime = 0 and    (self squares at: 1) y prime = 0.predicate PentoShapes fromsValid    all i in self froms prime allButFirst | i > 0.predicate PentoShapes fromDirsValid    all i in self fromDirs prime | i > 0 and i <= 4.predicate PentoShapes goUp     all s in self squares | s y prime >= 0.predicate PentoShapes noLeftFirstRow     all s in self squares | s y prime  > 0 or s x prime >= 0.predicate PentoShapes fromThat      all i in self froms prime indices allButFirst | (self froms prime at: i) < i.predicate PentoShapes distinct       all s1, s2 in self squares | s1 = s2 or (s1 equals: s2) not. predicate PentoShapes sprouted     all i in self squares indices allButFirst |  (self squares at: (self froms prime at: i)) plus:     (self dirs at: (self fromDirs prime at: i)) equals:         (self squares at: i).""      STEP 4: Define goal method for ESOOPPentoShapes  ""goal PentoShapes findShape     self fromDirsValid and     self fromsValid and    self atOrigin and    self fromThat and     self goUp and     self noLeftFirstRow and    self distinct and    self sprouted."! !!ESOOPCompiler class methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 16:46'!testSort    "        STEP 3: Run test (after previous steps)       * bring up solver server first *       ESOOPCompiler testSort.    "    | l1 |    ESOOPInteger setBounds: #(0 30).    l1 := ESOOPList withAll: (#(3 4 5 4 2 1) collect: [:x | ESOOPInteger new: x ]).    l1 solve: #sort.    ^l1"      STEP 1: Define predicate methods for ESOOPList  ""predicate List sorted     all i in self indices allButLast | (self at: i) <= (self at: (i+1)).predicate List permutationOf: L     all e in all Integer | self occurrencesOf: e = L occurrencesOf: e. ""      STEP 2: Define goal predicate methods for ESOOPList  ""goal List sort     self prime permutationOf: self and     self prime sorted. ""      STEP 4: Define goal optimization method for ESOOPList  (and repeat test) ""goalOptimization List sort bubbleSort       [  | s t |       s := self size - 1. <--- introduce a bug here by commenting the (- 1) !!        s to: 1 by: -1 do:[:i |         1 to: i do: [:j |           ( (self at: j) > (self at: (j+1)) ) ifTrue:              [ t := self at: j. self at: j put: (self at: (j+1)). self at: (j+1) put: t ] ] ].      ^self ]."! !!ESOOPCompiler class methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 12:28'!workspaceSnapshot" ∀ ∃ ≠∊  ≤≥ ∧∨ ′codeJ := '-2'.codeJ := 'predicate List blah ∀ i ∊ self indices | ∃ j ∊ self indices | (self at: i) ≤ (self at: j).'treesJ := ESOOPParser matchAll: codeJ with: #esoopProgram.trans := ESOOPDeParser match: (treesJ at: 3) with: #start.   res := ESOOPCompiler evaluate: codeJ.  treesJ := ESOOPParser matchAll: codeJ with: #numberOop.ESOOPLog0Atom AtomCtr.ESOOPLog0Variable VarCtr.ESOOPLog0Pointer PtrCtr.ESOOPLog0Relation RelCtr.ESOOPInteger MaxInt: 4.'ESOOPInteger setBounds: #(-3 5).dirs := ESOOPList withAll: (#((0 1) (0 -1) (-1 0) (1 0)) collect:                [:p | ESOOPPoint new x: (ESOOPInteger new: p first);                                                     y: (ESOOPInteger new: p second); yourself ]).squares := ESOOPList withAll: ((1 to: 4) collect:                [:p | ESOOPPoint new x: (ESOOPInteger new: 0);                                                     y: (ESOOPInteger new: 0); yourself ]).froms := ESOOPList new.fromDirs := ESOOPList new. pentoShape := ESOOPPentoShapes new                               dirs: dirs; squares: squares; fromDirs: fromDirs;                               froms: froms; yourself.                                   'pentoShape fromDirsValid.pentoShape fromThat.pentoShape log0fromDirs stringpentoShape squares  log0rel.pentoShape goal0findShape.pentoShape log0sprouted string.pentoShape log0goal0findShape. pentoShape solve: #findShape.pentoShape squares log0#AB OrderedCollectionpentoShape fromDirs. an ESOOPList(4 3 3 4 4)pentoShape froms.   an ESOOPList(5 1 1 1 4)pentoShape squares.  an ESOOPList(1@1 5@3 0@1 5@2)myC1 := ESOOPPentoShapes.myC2 := ESOOPPoint.myC1 log0bounds.myC1 instVarTypes.myC1 log0instVarRels.myC1 log0instVarRels valuesmyC2 Log0instVarRels. (myC1 log0instVarRels at: #fromDirs0prime) isaListInstVar(myC2 Log0instVarRels at: #) myC1 log0instVarRels keys collect: [:k | {k.  (myC1 log0instVarRels at: k) id} ]   a Set(#(#fromDirs0prime #'m3_4') #(#froms0prime #'m3_1') #(#froms #'m3_5') #(#fromDirs #'m3_8') #(#dirs #'m3_6') #(#dirs0prime #'m3_3') #(#squares #'m3_7') #(#squares0prime #'m3_2'))myC2 Log0instVarRels keys collect: [:k | {k.  (myC2 Log0instVarRels at: k) id} ]  ESOOPLogSolver init.ESOOPLog0Atom AtomToObjMap.ESOOPLogSolver ProblemRels. (ESOOPLogSolver ProblemRels at: #'m3_4' )isaListInstVar:Behaviornew changeq :=  ESOOPPoint new x: (ESOOPInteger new: 100); y: (ESOOPInteger new: 200); yourself.q equals: q(p log0equals: q) stringx := ESOOPList withAll: {ESOOPInteger new: 3.  ESOOPInteger new: 1}.(x log0permutationOf: x) strings := x log0goal0sort.s first first pointeeInstVarESOOPInteger allInstances ESOOPInteger log0boundsESOOPLog0Object resetCtrs.ESOOPUserTypes log0instVarRels'ESOOPInteger setBounds: #(0 30).l1 := ESOOPList withAll: (#(3 4 5 1 2) collect: [:x | ESOOPInteger new: x ]).'l1 log0rel log0l1.l1 sorted.l1 goal0sort.l1 log0goal0sort.l1 solve: #sort.l1 bubbleSort.l1 log0rel fixedSize 5l1 log0indices string u5l1 log0indices log0allButFirst sl1 log0rel isaListInstVar(ESOOPInteger new: 10) log0 isSymbolb := ESOOPLBox extent: (100)@(200) color: Color white.b log0LesserphicMorph new'ESOOPInteger setBounds: #(0 50).grid := 60.xMax := 20.yMax := 13.boxes := OrderedCollection new.bs := #((2 4 8 2) (3 6 2 6) (5 5 8 4) (6 2 8 8) (14 4 4 4) (1 2 2 2)).w := LesserphicMorph new openInWorld.w extent: (grid * xMax)@(grid * yMax). bs do: [:b | | a | 	  a := ESOOPLBox extent: (grid * b third)@(grid * b fourth) color: Color white.        a shape borderWidth: 2.	  w window add: a.	  a container translation: (grid * b first)@(grid * b second).         boxes add: a ]. v1 := ESOOPAllAppsViewer new                  scale: (ESOOPInteger new: 1);                  xMax: ((ESOOPInteger new: 1200)/grid);                  yMax: ((ESOOPInteger new: 780)/grid);                  boxes: (ESOOPList withAll: boxes); yourself.'v1 boxes log0 [A0, A31], [A1, A32], [A2, A33], [A3, A34], [A4, A35], [A5, A36]v1 boxes u6@31ESOOPAllAppsViewerv1 log0noAppsOutOfScreen string v1 log0noAppsOverlap string v1 log0goal0snapshot.v1 log0boxes v1 draw.  v1 solve: #snapshot. v1 draw.   v1 boxes first perfrom: #left: with: String lfESOOPUserTypes UserTypesresetPtrCtr'predicate List sorted     all i in self indices allButLast | (self at: i) <= (self at: (i+1)).predicate List permutationOf: L     all e in all Integer | self occurrencesOf: e = L occurrencesOf: e. goal List sort     self prime permutationOf: self ∧ self prime sorted.  'class AppBox: Integer left, Integer top, Integer width, Integer height.class AllAppsViewer: Integer scale, Integer xMax, Integer yMax, 6 AppBox List boxes.""predicate AllAppsViewer noAppsOverlap ∀ B1, B2 ∊ its boxes |                     B1 = B2 ∨                     B1 left′ > B2 left′ + B2 width′ ∨                     B2 left′ > B1 left′ + B1 width′ ∨                     B1 top′ > B2 top′ + B2 height′ ∨                     B2 top′ > B1 top′ + B1 height′. predicate AllAppsViewer noAppsOutOfScreen ∀ B ∊ its boxes |                      B left′+ B width′ < its xMax ∧                       B top′+ B height′ < its yMax.predicate AllAppsViewer properlyScaled                      ∀ B ∊ its boxes |                           B width′ * its scale = B width ∧                           B height′ * its scale = B height.goal AllAppsViewer snapshot               its noAppsOverlap ∧ its noAppsOutOfScreen ∧ its properlyScaled.(ESOOPList with: 1) species name = #ESOOPListcodeJ := 'bound Integer [0,30].                  predicate List lineBreaks  { I ∊ its indices | it at: I = 0 }.                predicate List foo its lineBreaks size > 4 ∧                   ∀ I ∊ (its lineBreaks indices - its lineBreaks lastIndex) |                    (it copyFrom: (its lineBreaks at: I + 1) to: (its lineBreas at: (I+1))) sum = 10.                goal List blah it′ foo.                L1 ← [7,10,2,4,3,9,3,8,13,5,20,18,9,20,1,10,5,7,12,2,8,5,19,15,5,4,13,11,4,17].                  L1 solve: blah. L1.'.′ codeP := 'List blah [ ^5] '.treesP := ObjectParser matchAll: codeP with: #start. transP := ObjectDeParser match: treesP first with: #start.′String streamContents: [:s | 16r2032 to: 16r22FF do: [:c | s nextPut: c asCharacter. c \\ 16 = 15 ifTrue: [s cr]]].  ′″‴‵‶‷‸‹›※‼‽‾‿⁀⁁⁂⁃⁄⁅⁆⁇⁈⁉⁊⁋⁌⁍⁎⁏⁐⁑⁒⁓⁔⁕⁖⁗⁘⁙⁚⁛⁜⁝⁞ ⁠⁡⁢⁣⁤⁥⁦⁧⁨⁩⁪⁫⁬⁭⁮⁯⁰ⁱ⁲⁳⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾ⁿ₀₁₂₃₄₅₆₇₈₉₊₋₌₍₎₏ₐₑₒₓₔₕₖₗₘₙₚₛₜ₝₞₟₠₡₢₣₤₥₦₧₨₩₪₫€₭₮₯₰₱₲₳₴₵₶₷₸₹₺₻₼₽₾₿⃀⃁⃂⃃⃄⃅⃆⃇⃈⃉⃊⃋⃌⃍⃎⃏⃒⃓⃘⃙⃚⃐⃑⃔⃕⃖⃗⃛⃜⃝⃞⃟⃠⃡⃢⃣⃤⃥⃦⃪⃫⃨⃬⃭⃮⃯⃧⃩⃰⃱⃲⃳⃴⃵⃶⃷⃸⃹⃺⃻⃼⃽⃾⃿℀℁ℂ℃℄℅℆ℇ℈℉ℊℋℌℍℎℏℐℑℒℓ℔ℕ№℗℘ℙℚℛℜℝ℞℟℠℡™℣ℤ℥Ω℧ℨ℩KÅℬℭ℮ℯℰℱℲℳℴℵℶℷℸℹ℺℻ℼℽℾℿ⅀⅁⅂⅃⅄ⅅⅆⅇⅈⅉ⅊⅋⅌⅍ⅎ⅏⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞⅟ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿↀↁↂↃↄↅↆↇↈ↉↊↋↌↍↎↏←↑→↓↔↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪⇫⇬⇭⇮⇯⇰⇱⇲⇳⇴⇵⇶⇷⇸⇹⇺⇻⇼⇽⇾⇿∀∁∂∃∄∅∆∇∈∉∊∋∌∍∎∏∐∑−∓∔∕∖∗∘∙√∛∜∝∞∟∠∡∢∣∤∥∦∧∨∩∪∫∬∭∮∯∰∱∲∳∴∵∶∷∸∹∺∻∼∽∾∿≀≁≂≃≄≅≆≇≈≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩≪≫≬≭≮≯≰≱≲≳≴≵≶≷≸≹≺≻≼≽≾≿⊀⊁⊂⊃⊄⊅⊆⊇⊈⊉⊊⊋⊌⊍⊎⊏⊐⊑⊒⊓⊔⊕⊖⊗⊘⊙⊚⊛⊜⊝⊞⊟⊠⊡⊢⊣⊤⊥⊦⊧⊨⊩⊪⊫⊬⊭⊮⊯⊰⊱⊲⊳⊴⊵⊶⊷⊸⊹⊺⊻⊼⊽⊾⊿⋀⋁⋂⋃⋄⋅⋆⋇⋈⋉⋊⋋⋌⋍⋎⋏⋐⋑⋒⋓⋔⋕⋖⋗⋘⋙⋚⋛⋜⋝⋞⋟⋠⋡⋢⋣⋤⋥⋦⋧⋨⋩⋪⋫⋬⋭⋮⋯⋰⋱⋲⋳⋴⋵⋶⋷⋸⋹⋺⋻⋼⋽⋾⋿"! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:19'!condFalse  = {#condFalse decompile                [stream nextPutAll: ' ifFalse: ['] decompile 	              [stream nextPut: $]]}     ! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:19'!condTrue  = {#condTrue decompile                [stream nextPutAll: ' ifTrue: ['] decompile 	              [stream nextPut: $]]}     ! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:22'!esoopArray  = {#esoopArray [stream nextPutAll: '{']               (decompile &(anything) [stream nextPutAll: '. '])* decompile?                   [stream nextPutAll: '}']}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:21'!esoopInteger  = {#esoopInteger [stream nextPutAll: '(ESOOPInteger new: ']                              decompile [stream nextPut: $)] }! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:22'!esoopList  = {#esoopList [stream nextPutAll: '(ESOOPList withAll: {']               (decompile &(anything) [stream nextPutAll: '. '])* decompile?                   [stream nextPutAll: '})']}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 22:01'!esoopMethod  =	{#esoopMethod		anything:t	&({#message anything:sel anything*})            decompile	      [stream cr]		decompile}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 7/1/2009 17:02'!goalOptDef  =	{#goalOptDef      [stream nextPut: $[]      decompile      [stream nextPutAll: ' ] on: Error do: [ ^self solve: ']      decompile      [stream nextPutAll: ' ]']}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:23'!log0Integer  =	{#log0Integer      [stream nextPutAll: '(ESOOPLog0Integer with: ']      decompile      [stream nextPutAll: ')']}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:23'!log0Parens  =	{#log0Parens      [stream nextPutAll: '''''('''' , ']      decompile      [stream nextPutAll: ' , '''')''''']}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:24'!log0Set  =	{#log0Set      [stream nextPutAll: '(ESOOPLog0Set with: ''']      decompile      [stream nextPutAll: ''')']}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:24'!log0String  =	{#log0String      [stream nextPut: $']      decompile      [stream nextPut: $']}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:24'!log0Variable  =	{#log0Variable      [stream nextPutAll: '(ESOOPLog0Variable with: ''']      decompile      [stream nextPutAll: ''')']}! !!ESOOPDeParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:25'!quantSubExprLog  =	{#quantSubExprLog      [stream nextPut: $[]      decompile      [stream nextPut: $.]      [stream cr; tab: level]      [stream nextPutAll: '( ESOOPLog0Formula with: ']      decompile      [stream nextPutAll: ' , ']      decompile      [stream nextPutAll: ' , '' ['' , ']      decompile      [stream nextPutAll: ' , ''] | '' , ']      decompile      [stream nextPutAll: ' string , ']      decompile      [stream nextPutAll: ' )']      [stream nextPutAll: '] value']}! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:07'!at: idx    ^super at: idx value! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:20'!at: idx put: e    super at: idx put: e.    ^log0rel at: (ESOOPInteger log0: idx) log0put: e  ! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:01'!copyFrom: s to: e    ^super copyFrom: s value to: e value! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:01'!deepCopy     | res |    res := ESOOPList new.    self do: [:x | res add: x copy ].    ^res! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 20:26'!indices    ^ESOOPList withAll: ((1 to: self size) collect: [:x | ESOOPInteger new: x ])! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/29/2009 14:28'!initPrime    ^prime := ESOOPList initPrime: self size! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:01'!lastIndex    ^ESOOPInteger new: self size! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:22'!log0    | r |    r := WriteStream with: ''.    1 to: (self size - 1) do: [:i |       r nextPutAll: '[' , (ESOOPInteger log0: i) , ', ' , (self at: i) log0 , '], ' ].    r nextPutAll: '[' , (ESOOPInteger log0: self size)  , ', ' , (self at: self size) log0 , ']'.    ^r contents! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 00:39'!log0at: idx		    ^ESOOPLog0AtomExpr with: (idx log0intValue string , '.' , self  log0rel id)                               ! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 13:18'!log0copyFrom: s to: e		     | v |      v := (ESOOPLog0Variable with: #S , ESOOPLog0Variable incrVarCtr asString) string.      ^ESOOPLog0Set with: '( { [' , v , ': one ' , self log0indices string , '] | sum(' ,             v , ') >= ' , s string , ' - 1 && sum(' , v , ') <= ' , e string , ' - 1 } -> '            , self log0range , ' & ' , self log0 , ' )'           ! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:23'!log0indices       | s |     s := log0rel fixedSize.    ^ESOOPLog0Set with: (ESOOPInteger log0fromOneTo: s) log0type: 'nil' log0listType: 'nil' log0listSize: s! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:23'!log0lastIndex     ^ESOOPLog0Set with: (ESOOPInteger log0: log0rel fixedSize)! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/29/2009 14:10'!log0occurrencesOf: itm      ^ESOOPLog0Integer with: ('#(' , self log0rel id , '.' , itm string , ')')! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 15:39'!log0preProblemLines   | spacer problem problemUnknowns funDefs |     spacer := ' '.     ESOOPLogSolver ProblemRels at: log0rel id asSymbol put: log0rel.     ESOOPLogSolver ProblemRels at: prime log0rel id asSymbol put: prime log0rel.     problemUnknowns := OrderedCollection new.     problem := WriteStream with: ''.     funDefs := WriteStream with: ''.     problem nextPutAll: 'solver: ' , ESOOPLogSolver Solver , spacer.     problem nextPutAll: 'symmetry_breaking: ' , ESOOPLogSolver SymmetryBreaking , spacer.     problem nextPutAll: 'flatten: ' , ESOOPLogSolver Flatten , spacer.     problem nextPutAll: 'bit_width: ' , ESOOPInteger bitWidth asString , spacer.     problem nextPutAll:  'univ: u' , (ESOOPLog0Atom AtomCtr + 1) asString , spacer.     ESOOPLogSolver ProblemRels associationsDo: [:a | | rel |        rel := a value.        problem nextPutAll: 'bounds ' , a key , ': ' , rel log0 , spacer.         rel isUnknown ifTrue:           [ problemUnknowns add: rel.            funDefs nextPutAll: rel log0funDef ] ].     problem nextPutAll: (ESOOPInteger log0intBounds , spacer).     problem nextPutAll: 'solve ' , spacer , funDefs contents.     "problem nextPutAll:  ((self log0instVarPtrs values select: [:x | x isUnknown ])        inject: '' into: [:x :e | x := x , (e pointee log0funDef: e)]) , spacer."     ^{problemUnknowns. problem contents}! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/29/2009 13:51'!log0prime"			    ^ (log0instVarPtrs           at: #prime           ifAbsentPut: [ | ESOOPTmp1 |                                  self initPrime.                                  ESOOPTmp1 := (#r , ESOOPLog0Pointer PtrCtr asString) asSymbol.                                  (ESOOPLog0Pointer with: ESOOPTmp1 )                                     pointeeObj: self instVar: #prime instVarType: ESOOPList                                      instVarTypeSize: self size  ;yourself ])"    ^prime! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:07'!log0range    ^ESOOPInteger log0allInstances string! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/29/2009 11:26'!log0rel    ^log0rel! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/29/2009 11:27'!log0rel: r    ^log0rel := r! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:08'!log0size   ^ESOOPLog0Integer with: '#(' , self log0 string , ')'! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:08'!log0sum     "(sum [S0: one u5 ] | sum(S0.r0))"    ^ESOOPLog0Integer with: '(sum [S0: one u' , self size asString , '] | sum(S0.' ,         self log0 , '))' ! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:08'!merge: L    | res |    res := ESOOPList new.    1 to: self size do: [:i | res add: {self at: i. L at: i} ].    ^res! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:09'!prime    ^prime! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:09'!prime: list    ^self replaceFrom: 1 to: self size with: list startingAt: 1 ! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:09'!quantExis: aBlock    self do: [:e | (aBlock valueWithArguments: {e}) ifTrue: [^true] ].    ^false! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:09'!quantUniv: aBlock    self do: [:e | (aBlock valueWithArguments: {e}) ifFalse: [^false] ].    ^true! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:24'!solve: goal    | problem sol unknowns unknownsAns |   ESOOPLogSolver init.   ESOOPLogSolver setOpts.   problem := self perform: (#log0goal0 , goal) asSymbol.   unknowns := problem first.   sol := ESOOPLogSolver askSolver: (problem second , #;).   sol first ifTrue:       [ | atoop |         atoop := ESOOPLog0Atom AtomToObjMap.         unknownsAns := sol second.          unknowns do:            [:uRel | | atomsAndVals  |               atomsAndVals := unknownsAns at: uRel id.              atomsAndVals do: [:av |                 self at: (atoop at: av first) value put: (atoop at: av second) ] ].        ^true ]    ifFalse: [^false].   ! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:10'!+ aList^self , (aList isCollection ifTrue: [ aList ] ifFalse: [ {aList} ])! !!ESOOPList methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:10'!- aList^self copy removeAllFoundIn:   (aList isCollection ifTrue: [ aList ] ifFalse: [ {aList} ]); yourself! !!ESOOPList class methodsFor: 'as yet unclassified' stamp: 'hs 6/23/2009 21:49'!compilerClass    ^ESOOPCompiler! !!ESOOPList class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:13'!initPrime: size    | res rel |    res := super withAll: #().    rel := ESOOPLog0Relation new: #prime domain: ESOOPInteger range: ESOOPInteger isaPrime: true.    rel fixedSize: size.    rel isaList: true.    1 to: res size do: [:i | rel at: (ESOOPInteger log0: i) log0put: (res at: i) ].    res log0rel: rel.    ^res! !!ESOOPList class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 18:59'!log0ptrSym   ^#r! !!ESOOPList class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 15:04'!withAllIntegers: intArr    ^ self withAll: (intArr collect: [:i | ESOOPInteger new: i ])   ! !!ESOOPList class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:13'!withAll: arr    | res rel |    res := super withAll: arr.    rel := ESOOPLog0Relation new: #ESOOPList domain: ESOOPInteger range: ESOOPInteger.    rel fixedSize: arr size.    rel isaList: true.    1 to: res size do: [:i | rel at: (ESOOPInteger log0: i) log0put: (res at: i) ].    res log0rel: rel.    res initPrime.    ^res! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:52'!asString    ^string! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:52'!cmpOp: op on: other    ^ESOOPLog0Formula with: ('(' , self log0sumValue , op , other log0sumValue , ')')! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 16:16'!formulaOp: op on: other    ^ESOOPLog0Formula with: ('(' , self string , op , other string , ')')! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 15:51'!isaListInstVar    ^isaListInstVar! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 15:54'!isaListInstVar: b     ^isaListInstVar := b! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 12:18'!log0at: idx		    ^ESOOPLog0AtomExpr with: (idx log0intAtomValue , '.' , self asString)         log0type: log0listType log0listType: 'nil' log0listSize: 'nil'! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 13:18'!log0copyFrom: s to: e		     | v |      v := (ESOOPLog0Variable with: #S , ESOOPLog0Variable incrVarCtr asString) string.      ^ESOOPLog0Set with: '( { [' , v , ': one ' , self log0indices string , '] | sum(' ,             v , ') >= ' , s string , ' - 1 && sum(' , v , ') <= ' , e string , ' - 1 } -> '            , self log0range , ' & ' , self string , ' )'! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 12:19'!log0intAtomValue    ^self log0intValue string! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:54'!log0intValue    ^ESOOPLog0Set with: ('Int [' , self asString , ']')! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 17:05'!log0listSize    ^log0listSize! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 17:05'!log0listSize: lSz    ^log0listSize := lSz! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/25/2009 16:51'!log0listType    ^log0listType! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/25/2009 14:45'!log0listType: lTp    ^log0listType := lTp! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:54'!log0occurrencesOf: itm      ^ESOOPLog0Integer with: ('#(' , self string , '.' , itm string , ')')! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:54'!log0size   ^ESOOPLog0Integer with: '#(' , self string , ')'! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:55'!log0sumValue    ^'sum (' , self string , ')'! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/25/2009 16:51'!log0type    ^log0type! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/25/2009 14:45'!log0type: tp    ^log0type := tp! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:55'!logOp: op on: other    ^ESOOPLog0Formula with: ('(' , self string , op , other string , ')')! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:55'!mathOp: op on: other    ^ESOOPLog0Set with: ('(' , self log0sumValue , op , other log0sumValue , ')')! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 12:42'!preOp: op    ^ESOOPLog0Formula with: ('(' , op , self string , ')')! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:55'!string     ^string! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 15:55'!stringAsQuantList     ^isaListInstVar ifTrue: [ string , '[1]' ] ifFalse: [ string ]! !!ESOOPLog0Object methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:56'!string: str    ^string := str! !!ESOOPLog0Atom methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 18:58'!log0intValue    ^self! !!ESOOPLog0Atom methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 18:58'!log0sumValue    ^'sum (' , self string , ')'! !!ESOOPLog0Atom methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 18:58'!mathOp: op on: other    ^ESOOPLog0Integer with: ('(' , self log0sumValue , op , other log0sumValue , ')')! !!ESOOPLog0AtomExpr methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 14:59'!log0intValue    ^self! !!ESOOPLog0AtomExpr methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 15:00'!log0sumValue    ^'sum (' , self string , ')'! !!ESOOPLog0AtomExpr methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 15:00'!mathOp: op on: other    ^ESOOPLog0Integer with: ('(' , self log0sumValue , op , other log0sumValue , ')')! !!ESOOPLog0Formula methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 14:48'!log0not    ^self preOp: '!! '! !!ESOOPLog0Integer methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:56'!cmpOp: op on: other    ^ESOOPLog0Formula with: ('(' , self log0sumValue , op , other log0sumValue , ')')! !!ESOOPLog0Integer methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 12:19'!log0intAtomValue    ^ESOOPInteger log0: string asNumber.! !!ESOOPLog0Integer methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:57'!log0intValue    ^self! !!ESOOPLog0Integer methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:57'!log0sumValue    ^string! !!ESOOPLog0Integer methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:57'!mathOp: op on: other    ^ESOOPLog0Integer with: ('(' , self log0sumValue , op , other log0sumValue , ')')! !!ESOOPLog0Object class methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 14:10'!initialize    ^self reset! !!ESOOPLog0Object class methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 16:23'!reset      | userCs |      ESOOPLog0Variable resetVarCtr.      ESOOPLog0Atom resetAtomCtr.      ESOOPLog0Relation resetRelCtr.      userCs := ESOOPUserTypes UserTypes.      userCs isNil ifFalse: [ userCs values do: [:c | c reset ] ].      ESOOPLogSolver init.     ^0! !!ESOOPLog0Object class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:52'!with: str    ^self new string: str; yourself! !!ESOOPLog0Object class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 23:23'!with: str log0type: tp log0listType: lTp log0listSize: lSz    ^self with: str log0type: tp log0listType: lTp log0listSize: lSz isaListInstVar: false! !!ESOOPLog0Object class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 23:22'!with: str log0type: tp log0listType: lTp  log0listSize: lSz isaListInstVar: b    ^(self with: str) log0type: tp; log0listType: lTp; log0listSize: lSz; isaListInstVar: b; yourself! !!ESOOPLog0Atom class methodsFor: 'as yet unclassified' stamp: 'hs 6/24/2009 17:44'!AtomCtr    ^AtomCtr! !!ESOOPLog0Atom class methodsFor: 'as yet unclassified' stamp: 'hs 6/27/2009 22:30'!AtomToObjMap    ^AtomToObjMap! !!ESOOPLog0Atom class methodsFor: 'as yet unclassified' stamp: 'hs 6/24/2009 17:59'!incrAtomCtr    AtomCtr ifNil: [ ^self resetAtomCtr ].    ^AtomCtr := AtomCtr + 1.  ! !!ESOOPLog0Atom class methodsFor: 'as yet unclassified' stamp: 'hs 6/24/2009 17:54'!new     ^super new string: #A ,  self incrAtomCtr asString; yourself! !!ESOOPLog0Atom class methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 20:52'!resetAtomCtr     AtomToObjMap := IdentityDictionary new.    ^AtomCtr := ESOOPInteger BoundsSize.! !!ESOOPLog0AtomExpr class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 15:01'!withSymbol: sym      ^self with: sym asString! !!ESOOPLog0AtomExpr class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 23:30'!with: str      ^self new string: str; isaListInstVar: false; yourself! !!ESOOPLog0Formula class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 23:30'!with: str      ^self new string: str; isaListInstVar: false; yourself! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 11:16'!at: key log0put: val    ^val species name == #ESOOPList         ifTrue: [ | c |                        c := self at: key put: OrderedCollection new.                        val do: [:e | c add: e log0 ] ]         ifFalse: [ self at: key put:  val log0 ]! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:40'!domain    ^isaList          ifTrue: [ ESOOPInteger log0fromOneTo: fixedSize ]         ifFalse: [ domain log0bounds ] ! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 22:46'!domain: d    ^domain := d! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 6/29/2009 14:22'!fixedSize    ^fixedSize! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 6/29/2009 14:22'!fixedSize: s    ^fixedSize := s! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 12:23'!fullDomainRange    | d r |      d := self domain.      r := self range.      ^isaListInstVar            ifTrue: [ d , '->' , self listInstVarDomain , '->' , r ]           ifFalse: [ d , '->' , r ]! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 21:12'!getDomain    ^domain! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 21:12'!getRange    ^range! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 6/24/2009 21:15'!id    ^id! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 6/24/2009 17:23'!id: x    ^id := x! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 6/27/2009 23:41'!instVar    ^instVar! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 6/27/2009 23:41'!instVar: n    ^instVar := n! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 21:12'!isaList    ^isaList! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 21:42'!isaListInstVar    ^isaListInstVar! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 13:19'!isaListInstVarSet       id := ('m3_' , id allButFirst) asSymbol.     subRels := IdentityDictionary new.    ^isaListInstVar := true! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 12:31'!isaListInstVar: b      ^isaListInstVar := b! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 21:13'!isaList: b    ^isaList := b! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:11'!isaPrime    ^isaPrime! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:12'!isaPrime: b    ^isaPrime := b! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:16'!isUnknown    ^isaPrime! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:44'!listInstVarDomain     ^(ESOOPInteger log0fromOneTo: fixedSize) asString! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 15:09'!log0    | lower o |    lower := self log0lowerBound.    self isUnknown ifTrue:      [  o := WriteStream with: ''.         o nextPutAll: '[', lower , ', ' , self fullDomainRange , ']'.          isaListInstVar ifTrue: [            subRels keys do: [:subrel |                o nextPutAll: ' bounds ' , subrel ,                   ': [{}, ' , self listInstVarDomain , '->' , self range , '] ' ] ].         ^o contents      ].    ^lower! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 14:05'!log0funDef     | d r o |        r := self range.        ^isaListInstVar             ifTrue: [ d := self listInstVarDomain.                          o := WriteStream with: ''.                          subRels associationsDo: [:assoc | | subrel |                             subrel := assoc key.                             o nextPutAll: 'FUNCTION(' ,  subrel , ', ' , d , '->one ' , r , ') && '.                             o nextPutAll: subrel , ' = ' , assoc value , '.' , id , ' && '].                          o contents ]            ifFalse: [ d := self domain.                           'FUNCTION(' ,  id , ', ' , d , '->one ' , r , ') && '  ].       ! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 15:13'!log0lowerBound    | r s |    r := WriteStream with: '{'.    self associationsDo: [:assoc | | k v |       k := assoc key asString.       v := assoc value.       v species name == #OrderedCollection         ifTrue: [ 1 to: v size do:                           [:x | r nextPutAll: ('[' , k , ', ' , (ESOOPInteger log0: x)  ,                                     ', ' , (v at: x) , '], ') ] ]         ifFalse: [ r nextPutAll: '[' , k , ', ' , v , '], ' ] ].    s := r contents.    ^(s copyFrom: 1 to: (1 max: (s size - 2))), '}'! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 11:35'!range     | r |     r := range log0bounds.    ^r    "^isaListInstVar ifTrue: [ 'xx->' , r ] ifFalse: [ r ]"! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 22:46'!range: r    ^range := r! !!ESOOPLog0Relation methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 13:18'!subRels    ^subRels! !!ESOOPLog0Relation class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 12:05'!incrRelCtr    RelCtr ifNil: [ ^RelCtr := 0 ].    ^RelCtr := RelCtr + 1.  ! !!ESOOPLog0Relation class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:14'!new: n domain: d range: r    ^self new: n domain: d range: r isaPrime: false! !!ESOOPLog0Relation class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:12'!new: n domain: d range: r isaPrime: p    ^super new  id: (#r , self incrRelCtr asString) asSymbol;          instVar: n; domain: d; range: r; isaList: false;  isaListInstVar: false;          isaPrime: p; yourself! !!ESOOPLog0Relation class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 12:04'!RelCtr    ^RelCtr! !!ESOOPLog0Relation class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 12:04'!resetRelCtr    ^RelCtr := 0! !!ESOOPLog0Set methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:33'!formulaOp: op on: other    ^ESOOPLog0Object with: ('(' , self  string , op , other string, ')')! !!ESOOPLog0Set methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 23:48'!log0allButFirst      " FIXME "    ^ESOOPLog0Set with: '(' ,          (isaListInstVar             ifTrue: [ (#u , (log0listSize - 1) asString , '@' , (ESOOPInteger log0num: 2) asString) , #. , self string ]           ifFalse: [ self string ,  ' & ' , (#u , (log0listSize - 1) asString , '@' , (ESOOPInteger log0num: 2) asString) ]) , ')'! !!ESOOPLog0Set methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:26'!log0allButLast      " FIXME "    ^self  mathOp: ' - ' on:         (ESOOPLog0Integer with: #A , (ESOOPInteger log0num: log0listSize) asString)! !!ESOOPLog0Set methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 15:45'!log0indices    ^ESOOPLog0Set with: (ESOOPInteger log0fromOneTo: log0listSize)          log0type: 'ESOOPList' log0listType: 'ESOOPInteger' log0listSize: log0listSize! !!ESOOPLog0Set methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:25'!log0lastIndex      ^ESOOPLog0Set with: #A , (ESOOPInteger log0: log0listSize) asString! !!ESOOPLog0Set methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:35'!log0sumValue    ^'sum (' , self string , ')'! !!ESOOPLog0Set methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:35'!mathOp: op on: other    ^ESOOPLog0Set with: ('(' , self string , op , other string, ')')! !!ESOOPLog0Set class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:32'!withSymbol: sym      ^self with: sym asString! !!ESOOPLog0Set class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 23:29'!with: str      ^self new string: str; isaListInstVar: false; yourself! !!ESOOPLog0Variable methodsFor: 'as yet unclassified' stamp: 'hs 6/23/2009 21:44'!log0intValue    ^self! !!ESOOPLog0Variable methodsFor: 'as yet unclassified' stamp: 'hs 6/30/2009 09:57'!log0sumValue        ^(log0type isNil or: [ log0type asSymbol = #ESOOPInteger ])         ifTrue: [ 'sum (' , self string , ')' ]         ifFalse: [ string ]! !!ESOOPLog0Variable class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 12:09'!incrVarCtr    VarCtr ifNil: [ ^VarCtr := 0 ].    ^VarCtr := VarCtr + 1.! !!ESOOPLog0Variable class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 12:09'!resetVarCtr    ^VarCtr := 0! !!ESOOPLog0Variable class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 12:09'!VarCtr    ^VarCtr! !!ESOOPLog0Variable class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 23:29'!with: str    ^self new string: str; isaListInstVar: false; yourself! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 15:27'!askSolver: problem    | result resParsed |      " clear out init msg "      SolverSocket upToAll: '!!'.      SolverSocket nextPutAll: problem; flush.      result := SolverSocket upToAll: '---STATS---'.      resParsed := ESOOPLogSolverOutputParser matchAll: result with: #output.      " close? "      QuitServerAfter ifTrue: [ SolverSocket nextPutAll: ' Bye;' ].      SolverSocket flush.      ^resParsed! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 22:12'!Flatten    ^Flatten! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:29'!Flatten: opt    ^Flatten := opt! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 22:12'!Host    ^Host! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 15:18'!init    ProblemRels := IdentityDictionary new.    ^true! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 16:21'!ProblemRels    ^ProblemRels! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 16:21'!ProblemRels: rels    ^ProblemRels := rels! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 14:55'!QuitServerAfter    ^QuitServerAfter! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 14:55'!QuitServerAfter: opt    ^QuitServerAfter! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 22:12'!Solver    ^Solver! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:29'!Solver: opt    ^Solver := opt! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 22:12'!SymmetryBreaking    ^SymmetryBreaking! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:30'!SymmetryBreaking: opt    ^SymmetryBreaking := opt! !!ESOOPLogSolver class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 15:27'!setOpts    Host := 'localhost'. "'tinlizzie.org'"    Port := 9128.    QuitServerAfter := true.    Solver := '"MiniSat"'.    Flatten := 'false'.    SymmetryBreaking := '10'.    ^SolverSocket := SocketStream openConnectionToHostNamed: Host port: Port    ! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/27/2009 23:32'!atom =     spaces <upper digit+>:a -> [a asSymbol]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 14:20'!binaryTuple =    lbrackets atom:a1 comma atom:a2 rbrackets    -> [{a1. a2}]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:40'!comma =     spaces "," ! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:40'!equals =     spaces "=" ! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:41'!header =    spaces "*** PROBLEM 1" spaces "***"! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:41'!instance =   spaces "---INSTANCE---" spaces "relations:" spaces lbraces     relations:rs rbraces spaces      -> [rs]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:15'!lbraces =    spaces "{"! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:16'!lbrackets =    spaces "["! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/27/2009 23:33'!list =    lbrackets listItems:is rbrackets    -> [is]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 14:21'!listItem =      binaryTuple  | ternaryTuple! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:16'!listItems =      listItems:is comma listItem:i      -> [is , {i}]  | listItem:i       -> [{i}]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 14:22'!name =	spaces <lower (letter | digit | "_")*>:ls -> [ls asSymbol]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:17'!outcome =    spaces "---OUTCOME---" spaces ("TRIVIALLY_"|"")! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:17'!output =   header (unsatOutcome:o | satOutcome:o instance:sol)     -> [{o. sol}]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:17'!rbraces =    spaces "}"! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:17'!rbrackets =    spaces "]"! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:17'!relation =     name:vn equals value:l    -> [{vn. l}]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:17'!relations =       relations:rs comma relation:r      -> [rs at: r first put: r second; yourself]  | relation:r      -> [IdentityDictionary new at: r first put: r second; yourself]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:17'!satOutcome =   outcome spaces "SATISFIABLE"    -> [true]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:18'!set =    lbrackets setItems:is rbrackets    -> [ESOOPList withAll: is]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:18'!setItem =    lbrackets number:i rbrackets    -> [i]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:18'!setItems =      setItems:is comma setItem:i      -> [is , {i}]  | setItem:i       -> [{i}]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 14:21'!ternaryTuple =    lbrackets atom:a1 comma atom:a2 comma atom:a3 rbrackets    -> [{a1. a2. a3}]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:18'!unsatOutcome =   outcome "UNSATISFIABLE" spaces    -> [false]! !!ESOOPLogSolverOutputParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:18'!value =    list | set! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:09'!addOpLog =	"+" -> [' + ']|	("-"|"\") -> [' - ']! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 17:09'!addOpOop =	"+" -> [#'+']|	("-"|"\") -> [#'-']! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:26'!all =    espaces ("all" | "∀")       -> ['all']! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:26'!assign =    espaces (":="|"←")! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:20'!assignInstVar =    (variableOop:o (name:x ~~name [{#unary. o. x}]:o)*)       name:p assign exprOop:v       -> [{#keyword. #setProperty:to:. o. p. v.}]	  ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:20'!assignment =     assignVar   | assignInstVar	  ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:20'!assignSubExpr =    (variableOop:o (name:x ~~name [{#unary. o. x}]:o)*)       name:p assign exprOop:v       -> [{#keyword. #setProperty:to:. o. p. v.}]	  ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:23'!assignVar =    variableOop:o assign exprOop:v       -> [{#assign.  o. v.}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:23'!bool =	"yes" -> [{#variable. #true}]|	"no" -> [{#variable. #false}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:23'!bottomExprLog =    bool  | collection  | variableLog  | word  | numberLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:23'!bottomExprOop =    bool  | collection  | variableOop  | word  | numberOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 12:33'!cmpOpLog =    espaces (      "=" -> [' = ']|	("~="|"≠") -> [' ~= ']|	(">="|"≥") -> [' >= ']|	("<="|"≤") -> [' <= ']|	">" -> [' > ']|	"<" -> [' < '] )! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 11:10'!cmpOpOop =    espaces (     "=" -> [#'=']|	("~="|"≠") -> [#'~=']|	(">="|"≥") -> [#'>=']|	("<="|"≤") -> [#'<=']|	">" -> [#'>']|	"<" -> [#'<'] )! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:24'!collection =    esoopList  | esoopSet! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:25'!colon =     espaces ":" ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:26'!comma =     espaces "," ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:26'!commaVals =	commaVals:es comma exprOop:e -> [es , {e}]|  exprOop:e -> [{e}]|  "" -> [{}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:26'!comment =     $" (~$" anything)* $"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:38'!esoopList =    lbracket commaVals:vs rbracket -> [{#esoopList} , vs] ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:38'!esoopProgram =	esoopStmts! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:38'!esoopSet =    lbraces commaVals:vs rbraces -> [{#esoopSet. vs}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/1/2009 16:09'!esoopStmt =    funDef | goalDef | goalOptDef! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:52'!esoopStmts =	esoopStmt:x "." esoopStmts:xs -> [x , xs]|	esoopStmt:x "." espaces -> [x]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:39'!espace =	space | comment! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:39'!espaces =	espace*! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:27'!exprLog =    exprLog:ps logOpLog:op predLog:p -> [{#keyword. #formulaOp:on:. ps. {#string. op}. p}]  | predLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:27'!exprOop =    exprOop:ps logOpOop:op predOop:p -> [{#keyword. op. ps. {#block. {#params}. p}}]  | predOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 12:30'!functionKwd =    espaces ("predicate"|"function")! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:27'!funDef =  ~~(funDefOop:s1) funDefLog:s2    -> [s2 , {s1}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 12:29'!funDefLog =  functionKwd espace+ type:tp    ( slctrAndVarsLog:svs [svs first]:n [svs second]:ps | name:n [{}]:ps )      [ps collect: [:x | x second]]:ps2      ( exprLog:v if exprLog:p [{#condTrue. p. {#return. v}}]:e 	       ( comma ( exprLog:v2 if exprLog:p2 [{#condTrue. p2.              {#return. v2}}]:e2 |                exprLog:v2 [v2]:e2 ) [{#sequence. e. e2}]:e)* |           exprLog:v [{#return. v}]:e )     [{{#message. (#log0 , n) asSymbol. nil. ps2}.       {#message. (tp , 0 asString , #log0 , n) asSymbol. nil. ps2}}]:msgs     [{#body. {#params}. e}]:body     [{#body. {#params}. {#return. {#keyword. #perform:withArguments:.              {#variable. #self}. {#unary. #asSymbol. {#binary. #','.                {#unary. #log0type. {#variable. #self}}.                   {#string. '0' , #log0 , n}}}. 	                  {#esoopArray} , ps}}}]:wrapBody       -> [{{#esoopMethod. {#symbol. tp}. msgs first. body}.                {#esoopMethod. {#symbol. #ESOOPLog0Variable}. msgs second. body}.                {#esoopMethod. {#symbol. #ESOOPLog0Variable}. msgs first. wrapBody}.                {#esoopMethod. {#symbol. #ESOOPLog0AtomExpr}. msgs second. body}.                {#esoopMethod. {#symbol. #ESOOPLog0AtomExpr}. msgs first. wrapBody}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 12:30'!funDefOop =  functionKwd espace+ type:tp     ( slctrAndVarsOop:svs [svs first]:n [svs second]:ps | name:n [{}]:ps )      [ps collect: [:x | x second]]:ps2      ( exprOop:v if exprOop:p [{#condTrue. p. {#return. v}}]:e 	       ( comma ( exprOop:v2 if exprOop:p2 [{#condTrue. p2.             {#return. v2}}]:e2 |              exprOop:v2 [{#return. v2}]:e2 ) [{#sequence. e. e2}]:e)* |           exprOop:v [{#return. v}]:e )    -> [{#esoopMethod. {#symbol. tp}. {#message. n. nil. ps2}. {#body. {#params}. e}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:34'!goalDef =  ~~(goalDefOop:s1) goalDefLog:s2    -> [{s2. s1}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:36'!goalDefLog =  "goal" espace+ type:tp name:n exprLog:v    -> [{#esoopMethod. {#symbol. tp}.           {#message. (#log0goal0 , n) asSymbol. nil. {}}.             {#body. {#params}.               {#sequence. {#temps. #esoopTmpVar1. #esoopTmpVar2}.                {#assign. {#variable. #esoopTmpVar1}. {#unary. #string. v}}.                {#assign. {#variable. #esoopTmpVar2}.                  {#unary. #log0preProblemLines. {#variable. #self}}}.                {#return. {#esoopArray.                   {#unary. #first. {#variable. #esoopTmpVar2}}.                  {#binary. #','.                     {#unary. #second. {#variable. #esoopTmpVar2}}.                        {#variable. #esoopTmpVar1}}}}}}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:35'!goalDefOop =  "goal" espace+ type:tp name:n exprOop:v    -> [{#esoopMethod. {#symbol. tp}.           {#message. (#goal0 , n) asSymbol. nil. {}}.             {#body. {#params}. {#return. v}}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/1/2009 17:00'!goalOptDef =  "goalOptimization" espace+ type:tp name:gn name:optn 	  squeakBlock:b    -> [{{#esoopMethod. {#symbol. tp}.           {#message. optn asSymbol. nil. {}}.             {#body. {#params}. {#goalOptDef. b. {#symbol. gn}}}}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:36'!if =    espaces "if"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:27'!in =    espaces ("in"|"∊")! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:37'!instVar =    ( numberOop:listSz type:listTp | [{#integer. '1'}]:listSz [nil]:listTp )	type:tp espace+ name:n -> [{tp. n. listSz. listTp}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:37'!instVars =	instVars:xs comma instVar:x -> [xs, {x}]|  instVar:x -> [{x}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:18'!it =    espaces "self"  -> [{#variable. #self}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:40'!lbraces =    espaces "{"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:40'!lbracket =    espaces "["! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:40'!listKwd =    espaces "List"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/1/2009 13:53'!logOpLog =        ("and"|"∧") -> [' && ']  | ("or"|"∨")  -> [' || ']! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:40'!logOpOop =        ("and"|"⋀") -> [#'and:']  | ("or"|"⋁")  -> [#'or:']! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:40'!lparen =    espaces "("! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:41'!makeObj =  "make" espace+ type:tp variableOop:n     (slctrAndValsOop:ivvs | "" [{}]:ivvs)         -> [{#assign. n. {#cascade. {#unary. #new. {#variable. tp}}} ,              (((ESOOPList withAll: ivvs first) merge: ivvs second) collect:                  [:iv |  {#cascadeSend. iv first. #cascadeNil. iv second} ]) ,                   {{#cascadeSend. #yourself. #cascadeNil}}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:41'!msgSendLog =	msgSendWArgsLog     | msgSendNoArgLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 11:54'!msgSendNoArgLog =	unaryPrimLog:ans ((nameOrSpecialSymLog:x ~colon [{#unary. (#log0 , x) asSymbol. ans}]:ans)+)           -> [ans]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 11:54'!msgSendNoArgOop =	unaryPrimOop:ans ((nameOrSpecialSymOop:x ~colon [{#unary. x. ans}]:ans)+)         -> [ans]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:42'!msgSendOop =	msgSendWArgsOop     | msgSendNoArgOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:42'!msgSendWArgsLog =	primNoArgExprLog:ans        (slctrAndValsLog:arg           [{#keyword. (#log0 , arg first) asSymbol. ans} , arg second]:ans)             -> [ans]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:42'!msgSendWArgsOop =	primNoArgExprOop:ans        (slctrAndValsOop:arg [{#keyword.          (arg first inject: '' into: [:x :e | x := x , e ] ) asSymbol. ans} ,             arg second]:ans)         -> [ans]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:42'!mulExprLog =	mulExprLog:x mulOp:op primExprLog:y            -> [{#keyword. #mathOp:on:. x. {#symbol. op}. y}]  |	primExprLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:42'!mulExprOop =	mulExprOop:x mulOp:op primExprOop:y -> [{#binary. op. x. y}]|	primExprOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:43'!mulOp =	"*" -> [#'*']  | "/" -> [#'/']! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:43'!name =	espaces ~nsKeyword <lower (letter | digit)*>:ls -> [ls asSymbol]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:35'!nameCap =	espaces ~nsKeyword <upper (letter | digit)*>:ls -> [ls asSymbol]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 11:55'!nameOrSpecialSymLog =    name:n prime        ->[(n , '0prime') asSymbol]   | prime  | name! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 11:56'!nameOrSpecialSymOop =    name:n prime        ->[n]   | prime        ->[#yourself]  | name! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:43'!not =    espaces "not"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 11:34'!notOpLog =    espaces 	("~="|"≠") -> [' !!= ']! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:21'!nsKeyword =    <letter (letter | digit)*>:k [k asLowercase]:k		 ?[#('and' 'or' 'if' 'of' 'in' 'all' 'some' 'self' 'prime') includes: k]      -> [k]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:01'!numberLog =         espaces <($-|) digit+>:ds -> [{#log0Integer. {#string. ds}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:00'!numberOop =         espaces <($-|) digit+>:ds -> [{#esoopInteger. {#integer. ds}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:44'!of =    espaces "of"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 12:44'!predLog =    valExprLog:a notOpLog:op valExprLog:b       -> [{#keyword. #preOp:. {#keyword. #cmpOp:on:. a. {#string. '='}. b}. {#string. '!! '}}]  | valExprLog:a cmpOpLog:op valExprLog:b       -> [{#keyword. #cmpOp:on:. a. {#string. op}. b}]  | quantExprLog  | valExprLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 11:32'!predOop =    valExprOop:a cmpOpOop:op valExprOop:b -> [{#binary. op. a. b}]  | quantExprOop  | valExprOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:44'!primExprLog =    msgSendLog  | unaryPrimLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:45'!primExprOop =    msgSendOop  | unaryPrimOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 12:21'!prime =    espaces ("′"|"prime")      -> [#prime]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:45'!primNoArgExprLog =      msgSendNoArgLog   | unaryPrimLog      ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:45'!primNoArgExprOop =      msgSendNoArgOop   | unaryPrimOop      ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:45'!quantExprLog =        quantSubExprLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:45'!quantExprOop =    ( all [#quantUniv:]:b | some [#quantExis:]:b  )         quantSubExprOop:e [e third]:bd            [e first do: [:v | bd := {#keyword. b. e second deepCopy.             {#block. {#params. v second}. bd}}]]:x [bd]:bd      -> [bd]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 12:06'!quantSubExprLog =    ( ((all | some):s [{#string. s}]:t [{#string. '('}]:lf  [{#string. ')'}]:rt)  |      "" [{#string. ''}]:t [{#string. '{'}]:lf  [{#string. '}'}]:rt  )      variablesLog:vs in valExprLog:l suchThat exprLog:e      [vs collect: [:v | {#assign. v.               {#keyword. #with:log0type:log0listType:log0listSize:. {#variable. #ESOOPLog0Variable}.                  {#binary. #','. {#symbol. #S}.                    {#unary. #asString. {#unary. #incrVarCtr.                      {#variable. #ESOOPLog0Variable}}}}.                  {#unary. #log0listType. l deepCopy}. {#variable. #nil}. {#variable. #nil}}}]]:as     [{#binary. #','. {#binary. #','. {#unary. #string. vs first}.         {#string. ': one '}}. {#unary. #stringAsQuantList. l}}]:vsStr     [vs allButFirst do: [:v |  vsStr := {#binary.  #','. {#binary. #','.  vsStr.           {#string. ', '}}. {#binary. #','. {#binary. #','.           {#unary. #string. v}. {#string. ': one '}}.               {#unary. #stringAsQuantList. l deepCopy}}} ]]:x      -> [{#quantSubExprLog.               {#sequence. {#temps} , (vs collect: [:v | v second])} , as.  lf. t. vsStr. e. rt}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:46'!quantSubExprOop =   variablesOop:vs in valExprOop:l suchThat exprOop:e      -> [{vs. l. e}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:46'!query =   exprOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:47'!rbraces =    espaces "}"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/1/2009 16:05'!rbracket =    espaces "]"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:47'!rparen =    espaces ")"! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:47'!setComprhLog =    all type:tp      -> [{#unary. #log0allInstances. {#squeak. tp}}]   | lbraces quantSubExprLog:e rbraces      -> [e]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 12:13'!setComprhOop =    all type:tp      -> [{#unary. #allInstancesAsList. {#squeak. tp}}]   | lbraces quantSubExprOop:e rbraces      -> [{#keyword. #select:. e second.               {#block. {#params. e first first second}.  e third}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 12:07'!slctr =	espaces ~nsKeyword <lower (letter | digit)*>:ls colon          -> [(ls , #':') asSymbol ]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 12:00'!slctrAndValLog =    slctr:s primNoArgExprLog:e-> [{s. e}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 12:00'!slctrAndValOop =    slctr:s primNoArgExprOop:e -> [{s. e}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:47'!slctrAndValsLog =  slctrAndValsLog:svs slctrAndValLog:sv       -> [{(svs first , sv first) asSymbol. svs second , {sv second}}]   | slctrAndValLog:sv       -> [{sv first. {sv second}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:48'!slctrAndValsOop =  slctrAndValsOop:svs slctrAndValOop:sv       -> [{svs first , {sv first}. svs second , {sv second}}]   | slctrAndValOop:sv       -> [{{sv first}. {sv second}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 11:59'!slctrAndVarLog =    slctr:s variableLog:v-> [{s. v}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 11:57'!slctrAndVarOop =    slctr:s variableOop:v -> [{s. v}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:48'!slctrAndVarsLog =  slctrAndVarsLog:svs slctrAndVarLog:sv       -> [{(svs first , sv first) asSymbol. svs second , {sv second}}]   | slctrAndVarLog:sv       -> [{sv first. {sv second}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:48'!slctrAndVarsOop =  slctrAndVarsOop:svs slctrAndVarOop:sv       -> [{(svs first , sv first) asSymbol. svs second , {sv second}}]   | slctrAndVarOop:sv       -> [{sv first. {sv second}}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:48'!some =    espaces ("some" | "∃")      -> ['some']! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/1/2009 16:43'!squeakBlock =    lbracket <~(rbracket espaces "." espaces ~_) _>*:b rbracket       -> [{#variable. b inject: '' into: [:x :e | x := x , e ]}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:52'!suchThat =    espaces ("|" | "such that")! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:49'!type =    variableOop:v -> [(#ESOOP , v second) asSymbol]  ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:49'!typeBounds =  "bound" espace+ type:tp esoopList:b       -> [{#keyword. #setBounds:. {#squeak. tp}. b}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:49'!unaryPrimLog =    lparen exprLog:e rparen -> [e]  | setComprhLog  | bottomExprLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:50'!unaryPrimOop =    lparen exprOop:e rparen -> [e]  | setComprhOop  | bottomExprOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:50'!valExprLog =	valExprLog:x addOpLog:op mulExprLog:y ->  [{#keyword. #mathOp:on:. x. {#string. op}. y}]|	mulExprLog! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:50'!valExprOop =	valExprOop:x addOpOop:op mulExprOop:y ->  [{#binary. op. x. y}]|	mulExprOop! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 12:04'!variableLog =	(name | nameCap): n	      -> [{#variable. n}]      | it           ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:20'!variableLogOld =	espaces (   <upper (letter | digit)*>:ls 	             -> [{#variable. ls asSymbol}]             | it           )! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 12:04'!variableOop =	(name | nameCap): n	             -> [{#variable. n}]     | it           ! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:19'!variableOopOld =	espaces (   <upper (letter | digit)*>:ls 	             -> [{#variable. ls asSymbol}]             | it           )! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:50'!variablesLog =     variablesLog:xs comma variableLog:x -> [xs, {x}]  |  variableLog:x -> [{x}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:50'!variablesOop =     variablesOop:xs comma variableOop:x -> [xs, {x}]  |  variableOop:x -> [{x}]! !!ESOOPParser methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 21:51'!word =	name:n -> [{#symbol. n}]! !!ESOOPUserTypes methodsFor: 'as yet unclassified' stamp: 'hs 6/24/2009 17:51'!log0     ^log0! !!ESOOPUserTypes methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 23:06'!log0bounds    ^'?->?'! !!ESOOPUserTypes methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 13:51'!log0preProblemLines   | spacer problem problemUnknowns funDefs |     spacer := ' '.     problemUnknowns := OrderedCollection new.     problem := WriteStream with: ''.     funDefs := WriteStream with: ''.     problem nextPutAll: 'solver: ' , ESOOPLogSolver Solver , spacer.     problem nextPutAll: 'symmetry_breaking: ' , ESOOPLogSolver SymmetryBreaking , spacer.     problem nextPutAll: 'flatten: ' , ESOOPLogSolver Flatten , spacer.     problem nextPutAll: 'bit_width: ' , ESOOPInteger bitWidth asString , spacer.     problem nextPutAll:  'univ: u' , (ESOOPLog0Atom AtomCtr + 1) asString , spacer.     ESOOPLogSolver ProblemRels associationsDo: [:a | | rel subrels |        rel := a value.        rel isaListInstVar ifTrue:           [ subrels := rel subRels.             rel getDomain esoopInstances do:                [:inst | subrels at: (#r , ESOOPLog0Relation incrRelCtr asString) asSymbol                                       put: inst log0 asSymbol ] ].        problem nextPutAll: 'bounds ' , a key , ': ' , rel log0 , spacer.         rel isUnknown ifTrue:           [ problemUnknowns add: rel.            funDefs nextPutAll: rel log0funDef ] ].     problem nextPutAll: (ESOOPInteger log0intBounds , spacer).     problem nextPutAll: 'solve ' , spacer , funDefs contents.     ^{problemUnknowns. problem contents}! !!ESOOPUserTypes methodsFor: 'as yet unclassified' stamp: 'hs 6/24/2009 17:51'!log0: x     ^log0 := x! !!ESOOPUserTypes methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 12:34'!solve: goal    | problem sol unknowns unknownsAns |   ESOOPLogSolver init.   ESOOPLogSolver setOpts.   problem := self perform: (#log0goal0 , goal) asSymbol.   unknowns := problem first.   sol := ESOOPLogSolver askSolver: (problem second , #;).   sol first ifTrue:       [ | atoop |         atoop := ESOOPLog0Atom AtomToObjMap.         unknownsAns := sol second.          unknowns do:            [:uRel | | atomsAndVals instVar |               instVar := uRel instVar.              atomsAndVals := unknownsAns at: uRel id.              uRel isaListInstVar                 ifTrue: [ (atoop at: atomsAndVals first first) perform: (instVar , #:) asSymbol                                     with: (ESOOPList withAll:                                         (atomsAndVals collect: [:x | atoop at: x last ])) ]                ifFalse: [  atomsAndVals do: [:av |                                   (atoop at: av first) perform: (instVar , #:) asSymbol                                                                  with: (atoop at: av second) ] ] ].        ^true ]    ifFalse: [^false].   ! !!ESOOPUserTypes methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 14:21'!updateRelsForFixedInstVar: instVar val: instVarVal      | listType listTpIVs listTpRels |       listType := Smalltalk at: (self species instVarTypes at: instVar) third asSymbol.      listTpIVs := listType instVarTypes keys.      listTpRels := listType log0instVarRels.      listTpIVs do: [:iv | | rel1 rel2 |          rel1 := listTpRels at: iv.          rel2 := listTpRels at: (iv , '0prime') asSymbol.          instVarVal do: [:itm | | itmlog |            itmlog := itm log0 asSymbol.             rel2 at: itmlog put: (rel1 at: itmlog) ] ].    ^true! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:13'!adaptToNumber: rcvr andSend: selector	^ rcvr perform: selector with: self asNumber! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:13'!asNumber    ^value! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 23:18'!initPrime    ^prime := ESOOPInteger new: nil.! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:13'!isZero    ^value isZero! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:14'!log0bounds: myPtr    ^'[{},' , ESOOPInteger log0allInstances string , ']'! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:14'!log0funDef: myPtr    ^'one ' , myPtr string , ' && '! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:14'!log0prime			    ^ (log0instVarPtrs           at: #prime           ifAbsentPut: [ | esoopTmp1 |                                  self initPrime.                                  esoopTmp1 := (#s , ESOOPLog0Pointer PtrCtr asString) asSymbol.                                  (ESOOPLog0Pointer with: esoopTmp1 )                                     pointeeObj: self instVar: #prime instVarType: ESOOPInteger                                      instVarTypeSize: 1  ;yourself ])! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:14'!log: num    ^value log: num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:15'!prime    ^prime! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:15'!prime: num    ^value := num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:15'!printOn: aStream    value printOn: aStream! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:15'!to: num    ^value to: num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:15'!value    ^value! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:16'!value: num    ^value := num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:16'!* num    ^ESOOPInteger new: value * num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:16'!+ num    ^ESOOPInteger new: value + num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:16'!- num    ^ESOOPInteger new: value - num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:16'!/ num    ^ESOOPInteger new: value / num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:17'!// num    ^ESOOPInteger new: value // num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:17'!< num    ^value < num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:17'!<= num    ^value <= num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 7/21/2009 21:03'!= num    ^value = num value! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:17'!> num    ^value > num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:18'!>= num    ^value >= num! !!ESOOPInteger methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:18'!\\ num    ^ESOOPInteger new: (value \\ num)! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 23:32'!class: supr subclass: class instanceVariables: ivs"    ESOOPUserTypes class: #Point subclass: #Point           instanceVariables: {{#x. #Integer. true}.                                             {#y. #Integer. true}}""    ESOOPUserTypes class: #LBox subclass: #LBox           instanceVariables: {{#left. #Integer}.                                             {#top. #Integer}.                                             {#width. #Integer}.                                             {#height. #Integer}}."    | s cC cN c cvtps ivNs varC logObjC anyIVFs log0instVarRelsD r1 r2 |    anyIVFs := false.    cN := (#ESOOP , class) asSymbol.    supr isNil        ifTrue: [       ivNs := ivs inject: '' into: [:x :e | x := x , e first , ' ' ].       ESOOPUserTypes subclass: cN instanceVariableNames: ivNs	     classVariableNames: '' poolDictionaries: '' category: 'ESOOP'.       c := Smalltalk at: cN ]      ifFalse: [     " if this is an existing class (thus won't be a subtype of ESOOPUserTypes so)       several methods need to be defined here... "      s := Smalltalk at: supr.      s subclass: cN instanceVariableNames: 'log0'	       classVariableNames: 'InstVarTypes Log0instVarRels InstAtomNumStart InstCtr' poolDictionaries: '' category: 'ESOOP'.      c := Smalltalk at: cN.      cC := c class.      cC reallyBasicCompile: 'compilerClass ^ESOOPCompiler' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'initInstVarTypes ^InstVarTypes := IdentityDictionary new' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'instVarTypes ^InstVarTypes' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'initRels ^Log0instVarRels := IdentityDictionary new' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'log0instVarRels ^Log0instVarRels' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'log0bounds ^self log0allInstances string' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'log0allInstances ^ESOOPLog0Set with: ''u'' , InstCtr asString , ''@'' , InstAtomNumStart asString' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'log0instVarRelsAt: x       | rel |       rel := Log0instVarRels at: x.       ESOOPLogSolver ProblemRels at: rel id asSymbol put: rel.       ^rel' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'reset        InstCtr := nil.        InstAtomNumStart := nil.        esoopInstances := OrderedCollection new.        Log0instVarRels associationsDo: [:a | | n r newr |           n := a key. r := a value.           newr := ESOOPLog0Relation                            new: n domain: r getDomain range: r getRange isaPrime: r isaPrime.          r isaListInstVar ifTrue: [ newr isaListInstVarSet. newr fixedSize: r fixedSize ].          Log0instVarRels at: n put: newr ].      ^true' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      cC reallyBasicCompile: 'new        | res atom |        InstAtomNumStart ifNil:           [ InstAtomNumStart := ESOOPLog0Atom AtomCtr + 1.            InstCtr := 0 ].        InstCtr := InstCtr + 1.        atom := ESOOPLog0Atom new string.        res := super new log0: atom; yourself.        esoopInstances add: res.        ESOOPLog0Atom AtomToObjMap at: atom asSymbol put: res.        ^res' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      c reallyBasicCompile: 'log0 ^log0' classified: 'ESOOP' withStamp: nil notifying: nil    logSource: false.      c reallyBasicCompile: 'log0: x ^log0 := x' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.    ].    UserTypes at: cN put: c.    varC := Smalltalk at: #ESOOPLog0Variable.    logObjC := Smalltalk at:  #ESOOPLog0AtomExpr.    cvtps := c initInstVarTypes.    c initRels.    ivs  do: [:iv| | ivN ivT ivF ivR ivListT ivListS log0exprTp ivpN isList isListStr getM setM setMxtra setpM log0getM log0prime0getM varLog0getM varLog0getMWrap varLog0prime0getM varLog0prime0getMWrap |      ivN := iv first.      ivpN := (ivN , '0prime') asSymbol.      ivT := #ESOOP , iv second.      ivF := iv third.      ivF ifFalse: [ anyIVFs := true ].      isList := iv size > 3.      isListStr := #false.      ivListT :=  'nil'.      ivListS := 'nil'.      ivR := ivT asSymbol.       log0exprTp := #ESOOPLog0AtomExpr.      setMxtra := ''.      isList ifTrue: [         ivListT := #ESOOP , iv fourth.         ivListS :=  iv fifth asString.         ivR :=  ivListT asSymbol.         log0exprTp := #ESOOPLog0Set.         isListStr := #true.         ivF ifFalse: [ setMxtra := String cr , String tab , 'self updateRelsForFixedInstVar: #', ivN ,' val: instVarVal. '] ].      cvtps at: ivN put: {ivT. ivF. ivListT}.      getM := ivN , String cr , String cr , String tab , '^' , ivN.      setM := ivN , ': instVarVal' , String cr , String cr , String tab ,                       '(self species log0instVarRels at: #' , ivN , ') at: self log0 asSymbol log0put: instVarVal.' , setMxtra ,                      String cr , String tab , '^' , ivN , ' := instVarVal'.      setpM := ivN , '0prime: instVarVal' , String cr , String cr , String tab ,                      String cr , String tab , '^ self ' , ivN , ': instVarVal'.      log0getM := #log0 , ivN , String cr , String cr , String tab , '^' , log0exprTp , ' with: ( ''('' , self log0 , #. , (self species log0instVarRelsAt: #' , ivN ,') id , '')'' ) log0type: ''' , ivT , ''' log0listType: ''' , ivListT , ''' log0listSize: ', ivListS , ' isaListInstVar: ', isListStr.      log0prime0getM := #log0 , ivN , '0prime' , String cr , String cr , String tab , '^' , log0exprTp , ' with: ( ''('' , self log0 , #. , (self species log0instVarRelsAt: #' , ivN , '0prime) id , '')'' ) log0type: ''' , ivT , ''' log0listType: ''' , ivListT , ''' log0listSize: ', ivListS , ' isaListInstVar: ', isListStr.     varLog0getM := cN , '0log0' , ivN , String cr , String cr , String tab , '^' , log0exprTp , ' with: ( ''('' , self string , #. , ((Smalltalk at: self log0type asSymbol) log0instVarRelsAt: #' , ivN ,') id , '')'' ) log0type: ''' , ivT , ''' log0listType: ''' , ivListT , ''' log0listSize: ', ivListS , ' isaListInstVar: ', isListStr.    varLog0prime0getMWrap := #log0 , ivN , '0prime' , String cr , String cr , String tab , '^self perform:  (self log0type , ''0log0'' , ''' , ivN , '0prime'') asSymbol.'.      varLog0prime0getM := cN , '0log0' , ivN  , '0prime' , String cr , String cr , String tab , '^' , log0exprTp , ' with: ( ''('' , self string , #. , ((Smalltalk at: self log0type asSymbol) log0instVarRelsAt: #' , ivN ,'0prime) id , '')'' ) log0type: ''' , ivT , ''' log0listType: ''' , ivListT , ''' log0listSize: ', ivListS , ' isaListInstVar: ', isListStr.      varLog0getMWrap := #log0 , ivN , String cr , String cr , String tab , '^self perform:  (self log0type , ''0log0'' , ''' , ivN , ''') asSymbol.'.      supr isNil ifTrue: [ c reallyBasicCompile: getM classified: 'ESOOP' withStamp: nil notifying: nil logSource: false ].      c reallyBasicCompile: setM classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.       c reallyBasicCompile: setpM classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.       c reallyBasicCompile: log0getM classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      c reallyBasicCompile: log0prime0getM classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.      {varC. logObjC} do: [:aC |         aC reallyBasicCompile: varLog0getM classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.        aC reallyBasicCompile: varLog0getMWrap classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.        aC reallyBasicCompile: varLog0prime0getM classified: 'ESOOP' withStamp: nil notifying: nil logSource: false.        aC reallyBasicCompile: varLog0prime0getMWrap classified: 'ESOOP' withStamp: nil notifying: nil logSource: false. ].      " make relations for instVars "     r1 := ESOOPLog0Relation new: ivN domain: c range: (Smalltalk at: ivR).     r2 := ESOOPLog0Relation new: ivpN domain: c range: (Smalltalk at: ivR) isaPrime: true.     isList ifTrue: [ {r1.r2} do: [:x | x isaListInstVarSet. x fixedSize: ivListS ] ].     log0instVarRelsD := c log0instVarRels.     log0instVarRelsD at: ivN put: r1.     log0instVarRelsD at: ivpN put: r2.    ].     anyIVFs ifTrue: [       c reallyBasicCompile: 'updateRelsForFixedInstVar: instVar val: instVarVal      | listType listTpIVs listTpRels |       listType := Smalltalk at: (self species instVarTypes at: instVar) third asSymbol.      listTpIVs := listType instVarTypes keys.      listTpRels := listType log0instVarRels.      listTpIVs do: [:iv | | rel1 rel2 |          rel1 := listTpRels at: iv.          rel2 := listTpRels at: (iv , ''0prime'') asSymbol.          instVarVal do: [:itm | | itmlog |            itmlog := itm log0 asSymbol.             rel2 at: itmlog put: (rel1 at: itmlog) ] ].    ^true' classified: 'ESOOP' withStamp: nil notifying: nil logSource: false ].    ^c! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 23:19'!compilerClass    ^ESOOPCompiler! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 13:47'!esoopInstances    ^esoopInstances! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 6/25/2009 15:10'!initInstVarTypes     ^instVarTypes := IdentityDictionary new! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 21:21'!initialize    "       ESOOPUserTypes initialize.       ESOOPUserTypes initRels.       ESOOPLogSolver init.    "     ^UserTypes := IdentityDictionary new! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 13:48'!initRels     ^log0instVarRels := IdentityDictionary new! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 6/25/2009 15:04'!instVarTypes    ^instVarTypes! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 23:27'!log0allInstances    ^ESOOPLog0Set with: 'u' , instCtr asString , '@' , instAtomNumStart asString! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 23:08'!log0bounds    ^self log0allInstances string! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 6/25/2009 15:04'!log0instVarRels    ^log0instVarRels! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 16:54'!log0instVarRelsAt: x     | rel |     rel := log0instVarRels at: x.     ESOOPLogSolver ProblemRels at: rel id asSymbol put: rel.     ^rel! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 13:50'!new    | res atom |      instAtomNumStart ifNil:         [ instAtomNumStart := ESOOPLog0Atom AtomCtr + 1.          instCtr := 0 ].      instCtr := instCtr + 1.      atom := ESOOPLog0Atom new string.      res := super new log0: atom; yourself.      esoopInstances add: res.      ESOOPLog0Atom AtomToObjMap at: atom asSymbol put: res.     ^res! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 7/6/2009 21:51'!newNoAtom   ^super new! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:15'!reset    instCtr := nil.    instAtomNumStart := nil.    esoopInstances := OrderedCollection new.    log0instVarRels associationsDo: [:a | | n r newr |       n := a key. r := a value.       newr := ESOOPLog0Relation                        new: n domain: r getDomain range: r getRange isaPrime: r isaPrime.      r isaListInstVar ifTrue: [ newr isaListInstVarSet. newr fixedSize: r fixedSize  ].      log0instVarRels at: n put: newr ].    ^true! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 7/25/2009 13:23'!subclass: class instanceVariables: ivs"    ESOOPUserTypes subclass: #PentoShapes       instanceVariables: {{#dirs. #List. false. #Point. 4}.                                          {#squares. #List. true. #Point. 5}.                                             {#froms. #List. true. #Integer. 5}.                                          {#fromDirs. #List. true. #Integer. 5}}.""    ESOOPUserTypes subclass: #AllAppsViewer           instanceVariables: {{#scale. #Integer}.                                             {#xMax. #Integer}.                                             {#yMax. #Integer}.                                             {#boxes. #List. #LBox}}."       ^ self class: nil subclass: class instanceVariables: ivs! !!ESOOPUserTypes class methodsFor: 'as yet unclassified' stamp: 'hs 6/26/2009 23:46'!UserTypes    ^UserTypes! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/6/2009 21:58'!allInstances    "^ESOOPList withAll: Bounds"    ^Bounds! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 12:18'!allInstancesAsList	^ ESOOPList withAll: (Bounds asArray collect: [:x | ESOOPInteger new: x ])! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 15:15'!BoundsSize    ^MaxInt - MinInt + 1! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/22/2009 20:52'!bitWidth    ^((self BoundsSize + 1) log: 2) ceiling + 2! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 16:18'!initialize    self setBounds: #(0 30).    ^true! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:12'!log0allInstances    ^ESOOPLog0Set withSymbol: #u , Bounds size asString! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 19:41'!log0fromOneTo: n       ^ #u , n asString , #@ , (-1 * MinInt + 1) asString! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 00:49'!log0fromZeroTo: n ^ MinInt = 0        ifTrue: [ #u , n asString ]      ifFalse: [ #u , n asString , '@' , (-1 * MinInt) asString ] ! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 15:48'!log0intBounds     | o atoop |      o := WriteStream with: ''.     atoop := ESOOPLog0Atom AtomToObjMap.     o nextPutAll: 'int_bounds: ' , MinInt asString ,': ['.     (MinInt to: (MaxInt - 1)) do: [:e | | a |          a := ESOOPInteger log0: e.         atoop at: a put: (ESOOPInteger new: e).          o nextPutAll: '{' , a , '},' ].     atoop at: (ESOOPInteger log0: MaxInt) put: (ESOOPInteger new: MaxInt).      o nextPutAll: ('{' , (ESOOPInteger log0: MaxInt) , '}]').     ^o contents! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/24/2009 17:38'!log0num: num    ^ num - MinInt! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 6/22/2009 19:12'!log0ptrSym   ^#s! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 14:46'!log0: num    ^(#A , (num - MinInt) asString) asSymbol! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 14:39'!MaxInt    ^MaxInt! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 14:39'!MinInt    ^MinInt! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/23/2009 14:46'!new: num    ^super newNoAtom value: num; log0: (self log0: num); yourself! !!ESOOPInteger class methodsFor: 'as yet unclassified' stamp: 'hs 7/26/2009 16:20'!setBounds: lowerUpper   MinInt := lowerUpper first.   MaxInt := lowerUpper second.   Bounds := MinInt  to: MaxInt.   ESOOPLog0Object reset.   ^true! !!LBox methodsFor: 'as yet unclassified' stamp: 'hs 7/7/2009 11:36'!log0 ^log0! !!LBox methodsFor: 'as yet unclassified' stamp: 'hs 7/7/2009 11:36'!log0: x ^log0 := x! !LBox class removeSelector: #InstVarTypes!LBox class removeSelector: #initInstVarTypes!LBox class removeSelector: #initRels!LBox class removeSelector: #Log0instVarRels!LBox class removeSelector: #Log0instVarRelsAt:!LBox class removeSelector: #log0allInstances!LBox class removeSelector: #log0bounds!LBox class removeSelector: #new!LBox class removeSelector: #reset!ESOOPInteger class removeSelector: #allInstancesOld!ESOOPInteger class removeSelector: #foo!ESOOPInteger initialize!ESOOPInteger class removeSelector: #log0bounds!ESOOPInteger class removeSelector: #MaxInt:!ESOOPInteger class removeSelector: #MinInt:!ESOOPInteger class removeSelector: #maxInt!ESOOPInteger class removeSelector: #new!ESOOPUserTypes class removeSelector: #basicNew!ESOOPUserTypes class removeSelector: #class:subclass:instanceVariablesOld:!ESOOPUserTypes class removeSelector: #class:subclass:instanceVariables:isNew:!ESOOPUserTypes class removeSelector: #compilerClassOld!ESOOPUserTypes class removeSelector: #InstVarTypes!ESOOPUserTypes initialize!ESOOPUserTypes class removeSelector: #Log0instVarRels!ESOOPUserTypes class removeSelector: #subclass:instanceVariablesOld:!ESOOPInteger removeSelector: #foo!ESOOPInteger removeSelector: #log0!ESOOPInteger removeSelector: #log0bounds!ESOOPUserTypes removeSelector: #esoopType!ESOOPUserTypes removeSelector: #log0instVarPtrs!ESOOPUserTypes removeSelector: #log0instVarPtrs:!ESOOPParser class removeSelector: #subclass:instanceVariables:!ESOOPParser removeSelector: #classDef!ESOOPParser removeSelector: #johnStmts!ESOOPParser removeSelector: #nameOrSpecialSym!ESOOPParser removeSelector: #slctrAndValLogOld!ESOOPParser removeSelector: #slctrAndValOopOld!ESOOPParser removeSelector: #slctrAndVarLogOld!ESOOPParser removeSelector: #slctrAndVarOopOld!ESOOPParser removeSelector: #slctrOld!ESOOPLogSolverOutputParser class removeSelector: #subclass:instanceVariables:!ESOOPLogSolverOutputParser removeSelector: #number!ESOOPLog0Variable class removeSelector: #incrPtrCtr!ESOOPLog0Variable class removeSelector: #PtrCtr!ESOOPLog0Variable class removeSelector: #resetPtrCtr!ESOOPLog0Variable removeSelector: #ESOOPAllAppsViewer0log0boxes!ESOOPLog0Variable removeSelector: #ESOOPAllAppsViewer0log0boxes0prime!ESOOPLog0Variable removeSelector: #ESOOPAllAppsViewer0log0scale!ESOOPLog0Variable removeSelector: #ESOOPAllAppsViewer0log0scale0prime!ESOOPLog0Variable removeSelector: #ESOOPAllAppsViewer0log0xMax!ESOOPLog0Variable removeSelector: #ESOOPAllAppsViewer0log0xMax0prime!ESOOPLog0Variable removeSelector: #ESOOPAllAppsViewer0log0yMax!ESOOPLog0Variable removeSelector: #ESOOPAllAppsViewer0log0yMax0prime!ESOOPLog0Variable removeSelector: #ESOOPAppBox0log0height!ESOOPLog0Variable removeSelector: #ESOOPAppBox0log0height0prime!ESOOPLog0Variable removeSelector: #ESOOPAppBox0log0left!ESOOPLog0Variable removeSelector: #ESOOPAppBox0log0left0prime!ESOOPLog0Variable removeSelector: #ESOOPAppBox0log0top!ESOOPLog0Variable removeSelector: #ESOOPAppBox0log0top0prime!ESOOPLog0Variable removeSelector: #ESOOPAppBox0log0width!ESOOPLog0Variable removeSelector: #ESOOPAppBox0log0width0prime!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0height!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0height0prime!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0left!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0left0prime!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0top!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0top0prime!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0width!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0width0prime!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0x!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0x0prime!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0y!ESOOPLog0Variable removeSelector: #ESOOPLBox0log0y0prime!ESOOPLog0Variable removeSelector: #ESOOPList0log0permutationOf:!ESOOPLog0Variable removeSelector: #ESOOPList0log0sorted!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0dirs!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0dirs0prime!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0distinct!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0froms!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0froms0prime!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0fromThat!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0goUp!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0points!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0points0prime!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0sprouted!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0sprouts!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0sprouts0prime!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0squares!ESOOPLog0Variable removeSelector: #ESOOPPentoShapes0log0squares0prime!ESOOPLog0Variable removeSelector: #ESOOPPoint0log0x!ESOOPLog0Variable removeSelector: #ESOOPPoint0log0x0prime!ESOOPLog0Variable removeSelector: #ESOOPPoint0log0y!ESOOPLog0Variable removeSelector: #ESOOPPoint0log0y0prime!ESOOPLog0Variable removeSelector: #log0boxes!ESOOPLog0Variable removeSelector: #log0boxes0prime!ESOOPLog0Variable removeSelector: #log0height!ESOOPLog0Variable removeSelector: #log0height0prime!ESOOPLog0Variable removeSelector: #log0left!ESOOPLog0Variable removeSelector: #log0left0prime!ESOOPLog0Variable removeSelector: #log0top!ESOOPLog0Variable removeSelector: #log0top0prime!ESOOPLog0Variable removeSelector: #log0width!ESOOPLog0Variable removeSelector: #log0width0prime!ESOOPLog0Relation class removeSelector: #incrPtrCtr!ESOOPLog0Relation class removeSelector: #new!ESOOPLog0Relation class removeSelector: #newDomain:range:!ESOOPLog0Relation class removeSelector: #PtrCtr!ESOOPLog0Relation class removeSelector: #resetPtrCtr!ESOOPLog0Relation removeSelector: #name!ESOOPLog0Relation removeSelector: #name:!ESOOPLog0Atom class removeSelector: #withSymbol:!ESOOPLog0Atom class removeSelector: #with:!ESOOPLog0Object initialize!ESOOPLog0Object class removeSelector: #resetCtrs!ESOOPLog0Object class removeSelector: #with:log0type:log0listType:!ESOOPLog0Object class removeSelector: #with:type:listType:!ESOOPLog0Integer removeSelector: #log0!ESOOPList class removeSelector: #compilerClassOld!ESOOPList class removeSelector: #testSort!ESOOPList class removeSelector: #withAllNoPrime:!ESOOPList removeSelector: #at:putOld:!ESOOPList removeSelector: #blah!ESOOPList removeSelector: #blah:!ESOOPList removeSelector: #bubbleSort!ESOOPList removeSelector: #goal0sort!ESOOPList removeSelector: #log0bounds:!ESOOPList removeSelector: #log0funDef:!ESOOPList removeSelector: #log0instVarPtrs!ESOOPList removeSelector: #log0instVarPtrs:!ESOOPList removeSelector: #log0preProblemLinesOld!ESOOPList removeSelector: #log0ptr!ESOOPList removeSelector: #permutationOf:!ESOOPList removeSelector: #solveOld:!ESOOPList removeSelector: #sorted!ESOOPDeParser removeSelector: #espopArray!ESOOPDeParser removeSelector: #essopArray!ESOOPDeParser removeSelector: #log0Pointer!ESOOPDeParser removeSelector: #squeakBlock!ESOOPCompiler class removeSelector: #testTextLayout!Compiler removeSelector: #foo!